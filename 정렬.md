# 정렬(Sorting)

- 정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말한다.



### 선택 정렬

- 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복한다.

  #### 선택 정렬 동작 예시

  - 정렬할 데이터를 준비한다.

  ![img](https://blog.kakaocdn.net/dn/BQIsZ/btqSAT2qQdP/S9GXSduQxtECNU8JYE8lk0/img.png)

  

  - **[Step 0]** 처리되지 않은 데이터 중 가장 작은 '0'을 선택해 가장 앞의 '7'과 바꾼다.

  ![img](https://blog.kakaocdn.net/dn/cD67ez/btqSEK4QDgj/Ykk96Y363k7kzp9oJdZDeK/img.png)

  

  - **[Step 1]** 처리되지 않은 데이터 중 가장 작은 '1'을 선택해 가장 앞의 '5'와 바꾼다.

  ![img](https://blog.kakaocdn.net/dn/bJviiF/btqSELW0QVZ/kCDb0cfCTpKbBlaLrZ3uE0/img.png)

  

  - **[Step 2]** 처리되지 않은 데이터 중 가장 작은 '2'를 선택해 가장 앞의 '9'와 바꾼다.

  ![img](https://blog.kakaocdn.net/dn/d7oABq/btqSASblbyW/eykLBePeURaIA0sAbDwnV0/img.png)

  

  - **[Step 3]** 처리되지 않은 데이터 중 가장 작은 '3'을 선택해 가장 앞의 '7'과 바꾼다.

  ![img](https://blog.kakaocdn.net/dn/WB4WL/btqSxC0Qwyx/R9TF0WwXaHj56xSyfcyeMK/img.png)

  

  - 이러한 과정을 반복하면 다음과 같이 정렬이 완료된다.

  ![img](https://blog.kakaocdn.net/dn/cmMDhj/btqSDuBcX12/7lWPr6yQFfUDySJz0mUDxk/img.png)

  [선택 정렬 소스 코드](https://github.com/PNU-the-one/Algorithm/blob/hjh/code/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC.py)

  

### 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.

- 선택 정렬에 비해 구현 난이도가 높지만, 일반적으로 더 효율적이다.

  #### 삽입 정렬 동작 예시

  - **[Step 0]** 첫 번째 데이터 '7'은 그 자체로 정렬이 되어 있다고 판단하고, 두 번째 데이터인 '5'가 어떤 위치로
    들어갈지 판단한다. '7'의 왼쪽으로 들어가거나 오른쪽으로 들어가거나 두 경우만 존재한다.

  ![img](https://blog.kakaocdn.net/dn/bjPFom/btqSpHPdH04/lyG6pKefDXj8hZWUMQBBq1/img.png)

  - **[Step 1]** 이어서 '9'가 어떤 위치로 들어갈지 판단한다.

  ![img](https://blog.kakaocdn.net/dn/b73z4m/btqSATnHHQA/XGvaECVwrV630qSArbebl0/img.png)

  - **[Step 2]** 이어서 '0'이 어떤 위치로 들어갈지 판단한다.

  ![img](https://blog.kakaocdn.net/dn/bo5T8W/btqSmAJwTa5/JW31yNRKJ2l5dKwHU2QJ9k/img.png)

  - **[Step 3]** 이어서 '3'이 어떤 위치로 들어갈지 판단한다.

  ![img](https://blog.kakaocdn.net/dn/sl2Rz/btqSmAQmtTD/qm7cNoApKRMXLuydzyHXgK/img.png)

  - 이러한 과정을 반복하면 다음과 같이 정렬이 완료된다.

  ![img](https://blog.kakaocdn.net/dn/brlhZo/btqSxB8GOie/FziHOdKlrgneqXKp9gCPQK/img.png)

  [삽입 정렬 소스 코드](https://github.com/PNU-the-one/Algorithm/blob/hjh/code/%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC.py)



### 퀵 정렬

- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법이다.

- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나이다.

- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘이다.

- 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정한다.

  #### 퀵 정렬 동작 예시

  - **[Step 0]** 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '7'이 선택되고
    오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택된다. 이제 이 두 데이터의 위치를 서로 변경한다.

  ![img](https://blog.kakaocdn.net/dn/UZEV8/btqSgLZa4d2/SHYU3Ae5LTgk2q4oA9ibiK/img.png)

  

  - **[Step 1]** 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '9'가 선택되고
    오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '2'가 선택된다. 이제 이 두 데이터의 위치를 서로 변경한다.

  ![img](https://blog.kakaocdn.net/dn/bXREGS/btqSxA25zF5/DgptA52E1UX52LWikPTOH0/img.png)

  

  - **[Step 2]** 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '6'이 선택되고
    오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '1'이 선택된다. 단, 이처럼 **위치가 엇갈리는 경우 '피벗'과 '작은 데이터'의 위치를 서로 변경**한다.

  ![img](https://blog.kakaocdn.net/dn/bK3xV0/btqSjAwo68V/KcGdeTW1qyccg4Q5HDPFKK/img.png)

  

  - **[분할 완료]** 이제 '5'의 왼쪽에 있는 데이터는 모두 5보다 작고, 오른쪽에 있는 데이터는 모두 '5'보다 크다는 특징이 있다. 이렇게 피벗을 기준으로 데이터 묶음을 나누는 작업을 **분할(Divide)**이라고 한다.

  ![img](https://blog.kakaocdn.net/dn/4bi9z/btqSEKX7iOF/hZpTh77SrdbXOGLyqkeHZ1/img.png)

  

  - **[왼쪽 데이터 묶음 정렬]** 왼쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행한다.

  ![img](https://blog.kakaocdn.net/dn/dg3NIp/btqSjAXo6El/DG6OcqQNvg3ZGcgkXcKje0/img.png)

  

  - [오른쪽 데이터 묶음 정렬] 오른쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행한다.
    - 이러한 과정을 반복하면 전체 데이터에 대해서 정렬이 수행된다.

  ![img](https://blog.kakaocdn.net/dn/nBkXP/btqSmzKGXje/pbTg1ONTlD2vrBlkeuEZzk/img.png)

  [퀵 정렬 소스 코드](https://github.com/PNU-the-one/Algorithm/blob/hjh/code/%ED%80%B5%EC%A0%95%EB%A0%AC.py)

### 계수 정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작하는 정렬 알고리즘이다.
  - 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능
- 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 ***O(N + K)*** 를 보장한다.

#### 계수 정렬 동작 예시

- **[Step 0]** 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트를 생성한다.

![img](https://blog.kakaocdn.net/dn/eRpaa6/btqSpGQjtBO/zHP5OYAyhbPDCX0fNmx7p1/img.png)



- **[Step 1]** 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.

![img](https://blog.kakaocdn.net/dn/doe7ls/btqSELQgkwu/bK7Ubiihg8AXrlJNj13Ek0/img.png)



- **[Step 2]** 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.

![img](https://blog.kakaocdn.net/dn/bk8SWF/btqSGiUBzsL/3FHK6dhFrS1ao2zzK4CckK/img.png)



- **[Step 3]** 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.

![img](https://blog.kakaocdn.net/dn/byFkZK/btqSEKKzUue/lsj1EplVpI5ZKqhM8ebOEK/img.png)



- **[Step 15]** 결과적으로 최종 리스트에는 각 데이터가 몇 번씩 등장했는지 그 횟수가 기록된다.

![img](https://blog.kakaocdn.net/dn/QmcKA/btqSmzKGZWI/YFJrHKqB9J7prO4dyWstjK/img.png)



- **결과를 확인할 때**는 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력한다.

![img](https://blog.kakaocdn.net/dn/b0JmWG/btqSpGv7l5Y/VGqPBmofhj1sI0QsvNdAsk/img.png)

![img](https://blog.kakaocdn.net/dn/bKAmdA/btqSjAXo8u9/ur3uFeK1CdWg9JA8hYuSs0/img.png)

![img](https://blog.kakaocdn.net/dn/SVgAF/btqSGi76bPo/skEPiPWMj9cdLc4bkClL8K/img.png)

![img](https://blog.kakaocdn.net/dn/cxHRfR/btqSEKDPP9o/yXWvKfD91SKdMPfhn9EWzK/img.png)

![img](https://blog.kakaocdn.net/dn/nE83l/btqSpHuYZlt/uKKINCxtoNL1DWXwloGaH0/img.png)

[계수 정렬 소스 코드]()

### 

## 정렬 알고리즘 비교하기

- 앞서 다룬 네 가지 정렬 알고리즘을 비교하면 다음과 같다.
- 추가적으로 대부분의 프로그래밍 언어에서 지원하는 표준 정렬 라이브러리는 최악의 경우에도 ***O(NlogN)*** 을 보장하도록 설계되어 있다.

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| :------------ | :--------------- | :---------- | :----------------------------------------------------------- |
| **선택 정렬** | *O(N²)*          | *O(N)*      | 아이디어가 매우 간단하다.                                    |
| **삽입 정렬** | *O(N²)*          | *O(N)*      | 데이터가 거의 정렬되어 있을 때는 가장 빠르다.                |
| **퀵 정렬**   | *O(NlogN)*       | *O(N)*      | 대부분의 경우에 가장 적합하며, 충분히 빠르다.                |
| **계수 정렬** | *O(N + K)*       | *O(N + K)*  | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작한다. |



[참고 영상](https://www.youtube.com/watch?v=KGyK-pNvWos&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=4&t=580s)